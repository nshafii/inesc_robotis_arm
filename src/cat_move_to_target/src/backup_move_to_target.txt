#include <ros/ros.h>


#include <cat_common/cloud_common.h>

#include <sensor_msgs/JointState.h>

#include <apriltags/AprilTagDetections.h>

#include "../include/cat_move_to_target/cilinder_detector_apriltags.hpp"
#include "../include/cat_move_to_target/pick.hpp"

#define MANIPULATOR_TAG_ID 5
#define CILINDER_TAG_ID 2

#include <pluginlib/class_loader.h>
#include <geometry_msgs/Pose.h>
#include <moveit/robot_model_loader/robot_model_loader.h>
#include <moveit/planning_interface/planning_interface.h>
#include <moveit/planning_scene/planning_scene.h>
#include <moveit/kinematic_constraints/utils.h>
#include <moveit_msgs/DisplayTrajectory.h>
#include <moveit_msgs/PlanningScene.h>


#include <robotis_controller_msgs/ControlTorque.h>
#include <robotis_controller_msgs/PublishPosition.h>


int main(int argc, char** argv){

//   CilinderDetectorApriltags ctags(argc, argv);
//   std::vector<int> id;
//   id.push_back(CILINDER_TAG_ID);
//   id.push_back(MANIPULATOR_TAG_ID);
//   ctags.init(id);


    ros::init(argc, argv, "move_to_target");
    ros::AsyncSpinner spinner(1);
    spinner.start();
    ros::NodeHandle nh("~");

    // initiate a planning object
    robot_model_loader::RobotModelLoader robot_model_loader("robot_description");
    robot_model::RobotModelPtr robot_model = robot_model_loader.getModel();

     ROS_INFO("Model frame: %s", kinematic_model->getModelFrame().c_str());

    // construct a planning scene to mantain the state of the world
    planning_scene::PlanningScenePtr planning_scene(new planning_scene::PlanningScene(robot_model));

    //construct loader to load a planner
    boost::scoped_ptr<pluginlib::ClassLoader<planning_interface::PlannerManager> > planner_plugin_loader;
    planning_interface::PlannerManagerPtr planner_instance;
    std::string planner_plugin_name;

//    //get the name of the planning plugin from the ROS param server and load the planner
//    if(!nh.getParam("planning_plugin", planner_plugin_name)){
//        ROS_FATAL_STREAM("Could not find planner plugin name");
//    }

    planner_plugin_name = "ompl_interface/OMPLPlanner";

    try{
        planner_plugin_loader.reset(new pluginlib::ClassLoader<planning_interface::PlannerManager>("moveit_core", "planning_interface::PlannerManager"));
    }
    catch(pluginlib::PluginlibException& ex){
        ROS_FATAL_STREAM("Exception while creating planning plugin loader " << ex.what());
    }


    try{
        planner_instance.reset(planner_plugin_loader->createUnmanagedInstance(planner_plugin_name));
        if(!planner_instance->initialize(robot_model, nh.getNamespace()))
                ROS_FATAL_STREAM("Could not initialize planner instance");
        ROS_INFO_STREAM("Using planning interface '" << planner_instance->getDescription() << "'");
    }
    catch(pluginlib::PluginlibException& ex)
    {
      const std::vector<std::string> &classes = planner_plugin_loader->getDeclaredClasses();
      std::stringstream ss;
      for (std::size_t i = 0 ; i < classes.size() ; ++i)
        ss << classes[i] << " ";
      ROS_ERROR_STREAM("Exception while loading planner '" << planner_plugin_name << "': " << ex.what() << std::endl
                       << "Available plugins: " << ss.str());
    }

    ros::WallDuration sleep_time(15.0);
    sleep_time.sleep();

    //Pose Goal
    //motion plan request, specifying the desired pose of the end-effector as input
    planning_interface::MotionPlanRequest req;
    planning_interface::MotionPlanResponse res;
    geometry_msgs::PoseStamped ps;
    ps.header.frame_id = "link1";
    ps.pose.position.x = -0.252;
    ps.pose.position.y = -0.15;
    ps.pose.position.z = 0.302;
    ps.pose.orientation.w = 1.0;

    //give a tolerance of 0.01m in position and 0.01 rads in orientation
    std::vector<double> tolerance_pose(3,0.01);
    std::vector<double> tolerance_angle(3,0.01);

    //create this request as a constraint
    req.group_name = "arm";
    moveit_msgs::Constraints pose_goal = kinematic_constraints::constructGoalConstraints("end_effector", ps, tolerance_pose, tolerance_angle);
    req.goal_constraints.push_back(pose_goal);

    //construct a planning context
    planning_interface::PlanningContextPtr context = planner_instance->getPlanningContext(planning_scene, req, res.error_code_);
    context->solve(res);
    if(res.error_code_.val!= res.error_code_.SUCCESS){
        ROS_ERROR("Could not compute plan successfully");
        return 0;
    }

    //Visualize the result

    ros::Publisher display_publisher = nh.advertise<moveit_msgs::DisplayTrajectory>("/move_group/display_planned_path", 1, true);
    moveit_msgs::DisplayTrajectory display_trajectory;

    /* Visualize the trajectory */
    ROS_INFO("Visualizing the trajectory");
    moveit_msgs::MotionPlanResponse response;
    res.getMessage(response);

    display_trajectory.trajectory_start = response.trajectory_start;
    display_trajectory.trajectory.push_back(response.trajectory);
    display_publisher.publish(display_trajectory);

    sleep_time.sleep();

//    //joint space goals

//    // set the state in the planning scene to the final state of the last plan
    robot_state::RobotState& robot_state = planning_scene->getCurrentStateNonConst();
    planning_scene->setCurrentState(response.trajectory_start);
    const robot_state::JointModelGroup* joint_model_group = robot_state.getJointModelGroup("arm");
    robot_state.setJointGroupPositions(joint_model_group, response.trajectory.joint_trajectory.points.back().positions);

//    //set new joint space
//    robot_state::RobotState goal_state(robot_model);
//    std::vector<double> joint_values(6, 0.0);
//    joint_values[3] = 0.03;
//    joint_values[4] = 1.35;
//    joint_values[5] = 1.43;

//    goal_state.setJointGroupPositions(joint_model_group, joint_values);

//    moveit_msgs::Constraints joint_goal = kinematic_constraints::constructGoalConstraints(goal_state, joint_model_group);
//    req.goal_constraints.clear();
//    req.goal_constraints.push_back(joint_goal);

    // Adding Path Constraints
     // ^^^^^^^^^^^^^^^^^^^^^^^
     // Let's add a new pose goal again. This time we will also add a path constraint to the motion.
     /* Let's create a new pose goal */
     ps.pose.position.x = -0.049;
     ps.pose.position.y = -0.235;
     ps.pose.position.z = 0.289;
     moveit_msgs::Constraints pose_goal_2 = kinematic_constraints::constructGoalConstraints("link1", ps, tolerance_pose, tolerance_angle);
     /* First, set the state in the planning scene to the final state of the last plan */
     robot_state.setJointGroupPositions(joint_model_group, response.trajectory.joint_trajectory.points.back().positions);
     /* Now, let's try to move to this new pose goal*/
     req.goal_constraints.clear();
     req.goal_constraints.push_back(pose_goal_2);

     /* But, let's impose a path constraint on the motion.
        Here, we are asking for the end-effector to stay level*/
     geometry_msgs::QuaternionStamped quaternion;
     quaternion.header.frame_id = "torso_lift_link";
     quaternion.quaternion.w = 1.0;
     req.path_constraints = kinematic_constraints::constructGoalConstraints("end_effector", quaternion);

     // Imposing path constraints requires the planner to reason in the space of possible positions of the end-effector
     // (the workspace of the robot)
     // because of this, we need to specify a bound for the allowed planning volume as well;
     // Note: a default bound is automatically filled by the WorkspaceBounds request adapter (part of the OMPL pipeline,
     // but that is not being used in this example).
     // We use a bound that definitely includes the reachable space for the arm. This is fine because sampling is not done in this volume
     // when planning for the arm; the bounds are only used to determine if the sampled configurations are valid.
     req.workspace_parameters.min_corner.x = req.workspace_parameters.min_corner.y = req.workspace_parameters.min_corner.z = -2.0;
     req.workspace_parameters.max_corner.x = req.workspace_parameters.max_corner.y = req.workspace_parameters.max_corner.z =  2.0;

     // Call the planner and visualize all the plans created so far.
     context = planner_instance->getPlanningContext(planning_scene, req, res.error_code_);
     context->solve(res);
     res.getMessage(response);
     display_trajectory.trajectory.push_back(response.trajectory);
     // Now you should see four planned trajectories in series
     display_publisher.publish(display_trajectory);

     //END_TUTORIAL
     sleep_time.sleep();
     ROS_INFO("Done");
     planner_instance.reset();


    return 0;

}




































